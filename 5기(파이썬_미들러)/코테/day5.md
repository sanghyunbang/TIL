# π§ λ‘ μ©μ•΅ λ¬Έμ  μ •λ¦¬

## π“ λ¬Έμ  μ„¤λ… (Problem Description)

### λ¬Έμ  λ°°κ²½
- KOI λ¶€μ„¤ κ³Όν•™μ—°κµ¬μ†μ—μ„λ” μ‚°μ„±(μμ νΉμ„±κ°’)κ³Ό μ•μΉΌλ¦¬μ„±(μ–‘μ νΉμ„±κ°’) μ©μ•΅μ„ νΌν•©ν•΄ **νΉμ„±κ°’μ ν•©μ΄ 0μ— κ°€μ¥ κ°€κΉμ΄ μ΅°ν•©**μ„ μ°Ύλ” μ—°κµ¬λ¥Ό μ§„ν–‰ μ¤‘μ…λ‹λ‹¤.
- μ©μ•΅μ νΉμ„±κ°’μ€ μ •μλ΅ μ£Όμ–΄μ§€λ©°, μ‚°μ„±μ€ μμ, μ•μΉΌλ¦¬μ„±μ€ μ–‘μλ΅ κµ¬λ¶„λ©λ‹λ‹¤.
- νΌν•©λ μ©μ•΅μ νΉμ„±κ°’μ€ λ‘ μ©μ•΅μ νΉμ„±κ°’ ν•©μΌλ΅ κ³„μ‚°λ©λ‹λ‹¤.

### μ”κµ¬μ‚¬ν•­
1. λ‘ μ©μ•΅μ„ νΌν•©ν• κ²½μ°, νΉμ„±κ°’ ν•©μ΄ 0μ— κ°€μ¥ κ°€κΉμ΄ μ΅°ν•©μ„ μ°Ύμµλ‹λ‹¤.
2. μ¶λ ¥μ€ ν•­μƒ **μ¤λ¦„μ°¨μ**μ΄μ–΄μ•Ό ν•©λ‹λ‹¤.
3. μ…λ ¥ μ΅°κ±΄:
   - \( N \) (μ©μ•΅ κ°μ): \( 2 \leq N \leq 100,000 \)
   - νΉμ„±κ°’ λ²”μ„: \(-1,000,000,000 \leq x \leq 1,000,000,000\)
   - νΉμ„±κ°’μ€ λ¨λ‘ **μ„λ΅ λ‹¤λ¥Έ** κ²ƒμ…λ‹λ‹¤.

---

## π’΅ λ¬Έμ  ν•΄κ²° λ°©λ²• (Solution Approach)

### 1βƒ£ **ν¬ ν¬μΈν„° λ°©μ‹ (Two Pointer Method)**

#### **κ°λ…**
- ν¬ ν¬μΈν„°(Two Pointer)λ” μ •λ ¬λ λ¦¬μ¤νΈμ—μ„ λ‘ ν¬μΈν„°(`left`μ™€ `right`)λ¥Ό μ–‘ λμ— λ°°μΉν•κ³ , νΉμ • μ΅°κ±΄μ— λ”°λΌ ν¬μΈν„°λ¥Ό μ΄λ™ν•λ©΄μ„ μµμ μ ν•΄λ¥Ό μ°Ύλ” μ•κ³ λ¦¬μ¦μ…λ‹λ‹¤.
- μ‹κ°„ λ³µμ΅λ„κ°€ \( O(N \log N) \)λ΅ ν¨μ¨μ μ΄λ©°, μ΄ λ¬Έμ μ™€ κ°™μ€ μ •λ ¬λ λ¦¬μ¤νΈ κΈ°λ°μ μµμ ν™” λ¬Έμ μ— μ ν•©ν•©λ‹λ‹¤.

#### **λ°©μ‹**
1. λ¦¬μ¤νΈλ¥Ό μ •λ ¬ν•©λ‹λ‹¤.
2. ν¬μΈν„° `left`λ” λ¦¬μ¤νΈμ μ²« λ²μ§Έ μ”μ†, `right`λ” λ§μ§€λ§‰ μ”μ†λ¥Ό κ²€μ‚¬ν•©λ‹λ‹¤.
3. λ‘ ν¬μΈν„°κ°€ κ²€μ‚¬ν•λ” ν•©μ„ κ³„μ‚°ν•μ—¬ λ‹¤μμ„ μν–‰ν•©λ‹λ‹¤:
   - ν•©μ΄ 0λ³΄λ‹¤ μ‘μΌλ©΄: `left`λ¥Ό μ¤λ¥Έμ½μΌλ΅ μ΄λ™ (λ” ν° κ°’μ„ νƒμƒ‰).
   - ν•©μ΄ 0λ³΄λ‹¤ ν¬λ©΄: `right`λ¥Ό μ™Όμ½μΌλ΅ μ΄λ™ (λ” μ‘μ€ κ°’μ„ νƒμƒ‰).
   - ν•©μ΄ μ •ν™•ν 0μ΄λ©΄ ν„μ¬ κ°’μ„ μµμ ν•΄λ΅ λ°ν™ν•©λ‹λ‹¤.
4. ν•©μ μ λ€κ°’μ΄ κ°€μ¥ μ‘μ€ μ΅°ν•©μ„ κ³„μ† κ°±μ‹ ν•©λ‹λ‹¤.

#### **μ¥μ **
- λ¨λ“  μ΅°ν•©μ„ ν• λ²μ λ£¨ν”„μ—μ„ ν¨μ¨μ μΌλ΅ νƒμƒ‰ κ°€λ¥ν•©λ‹λ‹¤.
- μ½”λ“κ°€ κ°„κ²°ν•μ—¬ μ΄ν•΄ν•κΈ° μ‰½μµλ‹λ‹¤.

---

### 2βƒ£ **μ΄λ¶„ νƒμƒ‰ λ°©μ‹ (Binary Search Method)**

#### **κ°λ…**
- μμμ™€ μ–‘μ λ¦¬μ¤νΈλ¥Ό λ¶„λ¦¬ν•κ³ , μμ λ¦¬μ¤νΈμ κ° κ°’μ— λ€ν•΄ μ–‘μ λ¦¬μ¤νΈμ—μ„ κ°€μ¥ κ°€κΉμ΄ κ°’μ„ **μ΄λ¶„ νƒμƒ‰**μΌλ΅ μ°Ύμµλ‹λ‹¤.
- μ΄λ¶„ νƒμƒ‰μ€ νΉμ • κ°’μ— λ€ν•΄ μƒν•(`ceil`)κ³Ό ν•ν•(`floor`)μ„ λΉ λ¥΄κ² μ°Ύλ” λ° μ μ©ν•©λ‹λ‹¤.

#### **λ°©μ‹**
1. λ¦¬μ¤νΈλ¥Ό μ •λ ¬ν•κ³  μμμ™€ μ–‘μ λ¦¬μ¤νΈλ¥Ό λ¶„λ¦¬ν•©λ‹λ‹¤.
2. μμ λ¦¬μ¤νΈμ κ° κ°’μ— λ€ν•΄ μ–‘μ λ¦¬μ¤νΈμ—μ„ μ΄λ¶„ νƒμƒ‰μΌλ΅ κ°€μ¥ κ°€κΉμ΄ κ°’μ„ μ°Ύμµλ‹λ‹¤:
   - `bisect_left`λ¥Ό μ‚¬μ©ν•μ—¬ μ‚½μ… μ„μΉλ¥Ό μ°Ύμµλ‹λ‹¤.
   - ν•΄λ‹Ή μ„μΉμ κ°’κ³Ό λ°”λ΅ μ΄μ „ κ°’(κ²½κ³„κ°’)μ„ λΉ λ¥΄κ² νƒμƒ‰ν•λ©° κ³„μ† λΉ„κµν•©λ‹λ‹¤.
3. κ°™μ€ λ¶€νΈλΌλ¦¬μ μ΅°ν•©(μμ-μμ, μ–‘μ-μ–‘μ)λ„ ν•΄λ‹Ήν•©λ‹λ‹¤.

#### **μ¥μ **
- νΉμ • κ°’κ³Ό κ°€μ¥ κ°€κΉμ΄ ν¬μΈν„°λ¥Ό μ°Ύλ” λ° μ μ©ν•©λ‹λ‹¤.
- ν¬ ν¬μΈν„° λ°©μ‹κ³Ό λΉ„μ·ν• ν¨μ¨μ μΈ νƒμƒ‰μ„ μ κ³µν•©λ‹λ‹¤.

---

## π” λ‚΄κ°€ μ‹¤μν–λ λ¶€λ¶„κ³Ό μ›μΈ (Mistakes in Original Code)

### **λ¬Έμ  1: λ¶ν•„μ”ν• μμ/μ–‘μ λ¶„λ¦¬ λ° λ³µμ΅ν• κ³„μ‚°**
- κΈ°μ΅΄ μ½”λ“μ—μ„ μμμ™€ μ–‘μ λ¦¬μ¤νΈλ¥Ό λ¶„λ¦¬ν• λ’¤ κ°κ°μ μ΅°ν•©μ„ λ‹¤λ¥Έ κ³„μ‚°μ„ ν†µν•΄ μ²λ¦¬ν•κ³ , μ΄ν›„ μμ-μ–‘μ μ΅°ν•©μ„ μ¶”κ°€λ΅ κ³„μ‚°ν–μµλ‹λ‹¤.
- μ΄ λ°©μ‹μ€ λΉ„ν¨μ¨μ μ΄λ©° μ½”λ“ λ³µμ΅μ„±μ„ μ¦κ°€μ‹μΌ°μµλ‹λ‹¤.

**μ‹¤μ  μ¤λ¥ μμ‹:**
- μ…λ ¥: `[-2, 4, -99, -1, 98]`
- λ¬Έμ  μƒν™©:
  - μμ λ¦¬μ¤νΈμ™€ μ–‘μ λ¦¬μ¤νΈλ¥Ό λ¶„λ¦¬ν•μ—¬ `start_Minus_gap`κ³Ό `start_Plus_gap`μ„ κ³„μ‚°ν–μ§€λ§, μµμ μ μμ-μ–‘μ μ΅°ν•©(μ: `-99`μ™€ `98`)μ΄ κ³ λ ¤λμ§€ μ•μ.
  - κ²°κ³Όμ μΌλ΅ μµμ  ν•΄λ¥Ό λ†“μΉ  κ°€λ¥μ„±μ΄ μ΅΄μ¬.

---

### **λ¬Έμ  2: μ΄λ¶„ νƒμƒ‰μ κ²½κ³„κ°’ μ²λ¦¬ μ¤λ¥**
- κΈ°μ΅΄ μ½”λ“μ—μ„ `min_index`μ™€ `max_index` κ²½κ³„λ¥Ό μλ» μ²λ¦¬ν•μ—¬ μλ»λ κ²°κ³Όκ°€ λ°μƒν•  κ°€λ¥μ„±μ΄ μμ—μµλ‹λ‹¤.
- νΉν μ΄λ¶„ νƒμƒ‰ ν›„ `mid_index`κ°€ λ¦¬μ¤νΈ κ²½κ³„μ— λ„λ‹¬ν–μ„ λ•, μΈλ±μ¤λ¥Ό μ΄κ³Όν•κ±°λ‚ λΉ„μ •ν™•ν• κ°’κ³Ό λΉ„κµν•λ” λ¬Έμ κ°€ μμ—μµλ‹λ‹¤.

**μ‹¤μ  μ¤λ¥ μμ‹:**
- μ…λ ¥: `[-1000000000, -1, 1, 1000000000]`
- λ¬Έμ  μƒν™©:
  - μ΄λ¶„ νƒμƒ‰μΌλ΅ μμ `-1`μ— λ€ν•΄ μ–‘μ λ¦¬μ¤νΈμ `1`μ„ μ°Ύμ•μΌλ‚, κ²½κ³„κ°’ κ²€μ¦ μ—†μ΄ κ³„μ‚°ν•μ—¬ λ…Όλ¦¬μ  μ¤λ¥ λ°μƒ.

---

## π› οΈ ν•΄κ²° μ½”λ“ (Refactored Solution)

### **ν¬ ν¬μΈν„° λ°©μ‹**
```python
import sys

# μ…λ ¥ μ²λ¦¬
data = sys.stdin.read().strip().split("\n")
N = int(data[0])
liquid = list(map(int, data[1].split()))
liquid.sort()

# ν¬ ν¬μΈν„° μ΄κΈ°ν™”
left, right = 0, N - 1
best_gap = float('inf')
best_pair = (0, 0)

while left < right:
    mix = liquid[left] + liquid[right]

    # μµμ κ°’ κ°±μ‹ 
    if abs(mix) < best_gap:
        best_gap = abs(mix)
        best_pair = (liquid[left], liquid[right])

    # ν¬μΈν„° μ΄λ™
    if mix < 0:
        left += 1
    elif mix > 0:
        right -= 1
    else:
        break

# κ²°κ³Ό μ¶λ ¥
print(*best_pair)
```

### **μ΄λ¶„ νƒμƒ‰ λ°©μ‹**
```python
import sys
from bisect import bisect_left

# μ…λ ¥ μ²λ¦¬
data = sys.stdin.read().strip().split("\n")
N = int(data[0])
liquid = list(map(int, data[1].split()))
liquid.sort()

# μμμ™€ μ–‘μ λ¦¬μ¤νΈ λ¶„λ¦¬
negatives = [x for x in liquid if x < 0]
positives = [x for x in liquid if x > 0]

# μµμ κ°’ μ €μ¥
best_gap = float('inf')
best_pair = (0, 0)

# μμ-μ–‘μ μ΅°ν•© νƒμƒ‰
for neg in negatives:
    idx = bisect_left(positives, -neg)

    for i in [idx - 1, idx]:
        if 0 <= i < len(positives):
            mix = neg + positives[i]
            if abs(mix) < best_gap:
                best_gap = abs(mix)
                best_pair = (neg, positives[i])

# κ°™μ€ λ¶€νΈλΌλ¦¬μ μ΅°ν•© νƒμƒ‰
for lst in [negatives, positives]:
    for i in range(len(lst) - 1):
        mix = lst[i] + lst[i + 1]
        if abs(mix) < best_gap:
            best_gap = abs(mix)
            best_pair = (lst[i], lst[i + 1])

# κ²°κ³Ό μ¶λ ¥
print(*sorted(best_pair))
```

---

## π€ κ²°λ΅  (Conclusion)
- **ν¬ ν¬μΈν„° λ°©μ‹**: μ§κ΄€μ μ΄κ³  κ°„κ²°ν•λ©°, μ •λ ¬λ λ¦¬μ¤νΈμ—μ„ λ¨λ“  μ΅°ν•©μ„ ν¨μ¨μ μΌλ΅ νƒμƒ‰ κ°€λ¥.
- **μ΄λ¶„ νƒμƒ‰ λ°©μ‹**: νΉμ • κ°’κ³Ό κ°€μ¥ κ°€κΉμ΄ μ”μ†λ¥Ό μ°Ύλ” λ° μ λ¦¬ν•λ‚, κ²½κ³„κ°’ μ²λ¦¬μ™€ κ°™μ€ μ¶”κ°€μ μΈ λ³µμ΅μ„± μ΅΄μ¬.

**λ‚΄ μ‹¤μμ—μ„ λ°°μ΄ μ **:
1. λ³µμ΅ν• λ΅μ§μ„ λ‹¨μν™”ν•λ©΄ λ¬Έμ λ¥Ό λ” ν¨μ¨μ μΌλ΅ ν•΄κ²°ν•  μ μμ.
2. μ΄λ¶„ νƒμƒ‰μ κ²½κ³„κ°’ κ²€μ¦μ€ ν•„μμ .
3. λ¬Έμ  μ”κµ¬μ‚¬ν•­(μ¤λ¦„μ°¨μ μ¶λ ¥ λ“±)μ„ ν•­μƒ λ…ν™•ν μ΄ν•΄ν•κ³  κµ¬ν„ν•΄μ•Ό ν•¨. π
